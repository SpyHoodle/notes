/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/macro_desc.json
var require_macro_desc = __commonJS({
  "src/macro_desc.json"(exports, module2) {
    module2.exports = {
      macros: [
        {
          syntax: "[KEYCODE]",
          description: "This is how you press a key, where `KEYCODE` is the name of the key you want pressed. Keycodes can be found <a >here</a>.",
          example: "[Enter] [Backspace]"
        },
        {
          syntax: "[KEYCODE]+[KEYCODE]",
          description: "+ is used to add a modifier eg: [Cmd]+[P] for pressing Command-P. Multiple modifiers are supported if you separate them with a space.",
          example: "[Cmd]+[P] [Cmd Shift]+[F]"
        },
        {
          syntax: ",DELAY,",
          description: ", is used to add a delay between key presses where `DELAY` is the amount in ms.",
          example: "[Cmd]+[P],100,[Enter]"
        },
        {
          syntax: '"TEXT"',
          description: '" is used to type text where `TEXT` is the text you want typed',
          example: '"Hello World"'
        },
        {
          syntax: "#COMMENT#",
          description: "# is used to add a comment where `COMMENT` is the comment you want to add.",
          example: "#This is a comment#"
        },
        {
          syntax: "\\CHAR",
          description: "\\ is used to escape a character where `CHAR` is the character you want to escape.",
          example: "\\["
        },
        {
          syntax: "{REPEAT}()",
          description: "{}() is used to repeat a sequence of keys where `REPEAT` is the sequence you want to repeat.",
          example: "{10}([Cmd]+[P] [Cmd]+[A] [Cmd]+[C] [Cmd]+[V] [Enter])"
        }
      ]
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TouchBarMacros
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/touchbar.ts
var ObsidianTouchBarItem = class {
  constructor(label, backgroundColor, macro) {
    this.label = label;
    this.backgroundColor = backgroundColor;
    this.id = this.generateId();
    this.macro = macro;
  }
  getLabel() {
    return this.label || "";
  }
  getBackgroundColor() {
    return this.backgroundColor;
  }
  getMacro() {
    return this.macro;
  }
  setLabel(label) {
    this.label = label;
  }
  setBackgroundColor(backgroundColor) {
    this.backgroundColor = backgroundColor;
  }
  generateId() {
    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
  }
  getId() {
    return this.id;
  }
};

// src/macro.ts
var electron = require("electron").remote;
function executeMacro(app, makro) {
  const commands = parseMacro(makro);
  executeCommands(app, commands);
}
var repeatcounter = 0;
async function executeCommands(app, commands) {
  var _a, _b, _c;
  console.log(commands);
  for (const command of commands) {
    if (command.command === MacroCommandType.RepeatStart) {
      repeatcounter = parseInt(command.argument);
    }
    if (repeatcounter > 0) {
      for (let i = 0; i < repeatcounter - 1; i++) {
        const insideCommands = commands.slice(commands.indexOf(command) + 1, commands.indexOf(commands.find((command2) => command2.command === MacroCommandType.RepeatEnd)));
        executeCommands(app, insideCommands);
      }
    }
    if (command.command === MacroCommandType.PressKey && ((_a = commands[commands.indexOf(command) + 1]) == null ? void 0 : _a.command) === MacroCommandType.PressKeys && ((_b = commands[commands.indexOf(command) + 2]) == null ? void 0 : _b.command) === MacroCommandType.PressKey) {
      pressKeys(app, command.argument, (_c = commands[commands.indexOf(command) + 2]) == null ? void 0 : _c.argument);
    } else {
      switch (command.command) {
        case MacroCommandType.PressKey:
          pressKey(app, command.argument);
          break;
        case MacroCommandType.AddText:
          addText(app, command.argument);
          break;
        case MacroCommandType.Delay:
          await waitFor(command.argument);
          break;
        case MacroCommandType.AddComment:
          break;
      }
    }
  }
}
function waitFor(argument) {
  return new Promise((resolve) => setTimeout(resolve, parseInt(argument)));
}
function addText(app, text) {
  console.log(text);
  const characters = text.split("");
  const win = electron.BrowserWindow.getFocusedWindow();
  characters.forEach((char) => {
    win.webContents.sendInputEvent({ keyCode: char, type: "char" });
  });
}
function pressKeys(app, key1, key2) {
  const win = electron.BrowserWindow.getFocusedWindow();
  const mods = key1.split(" ");
  win.webContents.sendInputEvent({ keyCode: key2, type: "keyDown", modifiers: mods });
  win.webContents.sendInputEvent({ keyCode: key2, type: "keyUp" });
}
function pressKey(app, key) {
  console.log(key);
  const browserWindow = electron.BrowserWindow.getFocusedWindow();
  browserWindow.webContents.sendInputEvent({ keyCode: key, type: "keyDown" });
  browserWindow.webContents.sendInputEvent({ keyCode: key, type: "keyUp" });
}
function parseMacro(macro) {
  const characters = macro.split("");
  const parsedCommands = [];
  let currentCommand = "";
  let currentArgument = "";
  let isEscaped = false;
  let commandStarted = false;
  let commandEscaped = false;
  characters.forEach((command) => {
    switch (command) {
      case "[":
        if (isEscaped || commandEscaped) {
          currentArgument += command;
          isEscaped = false;
          break;
        } else {
          commandStarted = true;
          currentCommand += command;
          break;
        }
      case "]":
        if (isEscaped || commandEscaped) {
          currentArgument += command;
          isEscaped = false;
          break;
        } else if (commandStarted) {
          commandStarted = false;
          currentCommand += command;
          parsedCommands.push({
            command: MacroCommandType.PressKey,
            argument: currentArgument
          });
          currentArgument = "";
          break;
        } else {
          currentArgument += command;
          break;
        }
      case "+":
        if (isEscaped || commandEscaped) {
          currentArgument += command;
          isEscaped = false;
          break;
        } else {
          commandStarted = false;
          currentCommand += command;
          parsedCommands.push({
            command: MacroCommandType.PressKeys,
            argument: ""
          });
          currentArgument = "";
          break;
        }
      case '"':
        if (isEscaped) {
          currentArgument += command;
          isEscaped = false;
          break;
        } else {
          commandEscaped = true;
          commandStarted = !commandStarted;
          currentCommand += command;
          if (!commandStarted) {
            parsedCommands.push({
              command: MacroCommandType.AddText,
              argument: currentArgument
            });
            commandEscaped = false;
          }
          currentArgument = "";
          break;
        }
      case "#":
        if (isEscaped || commandEscaped) {
          currentArgument += command;
          isEscaped = false;
          break;
        } else {
          commandStarted = !commandStarted;
          currentCommand += command;
          if (!commandStarted) {
            parsedCommands.push({
              command: MacroCommandType.AddComment,
              argument: currentArgument
            });
          }
          currentArgument = "";
          break;
        }
      case "\\":
        isEscaped = true;
        break;
      case ",":
        if (isEscaped || commandEscaped) {
          currentArgument += command;
          isEscaped = false;
          break;
        } else {
          commandStarted = !commandStarted;
          currentCommand += command;
          if (!commandStarted) {
            parsedCommands.push({
              command: MacroCommandType.Delay,
              argument: currentArgument
            });
          }
          currentArgument = "";
          break;
        }
      case "{":
        if (isEscaped || commandEscaped) {
          currentArgument += command;
          isEscaped = false;
          break;
        } else {
          commandStarted = !commandStarted;
          currentCommand += command;
          break;
        }
      case "}":
        if (isEscaped || commandEscaped) {
          currentArgument += command;
          isEscaped = false;
          break;
        } else {
          commandStarted = false;
          currentCommand += command;
          if (!commandStarted) {
            parsedCommands.push({
              command: MacroCommandType.RepeatStart,
              argument: currentArgument
            });
          }
          currentArgument = "";
          break;
        }
      case "(":
        if (isEscaped || commandEscaped) {
          currentArgument += command;
          isEscaped = false;
          break;
        } else {
          currentCommand += command;
          break;
        }
      case ")":
        if (isEscaped || commandEscaped) {
          currentArgument += command;
          isEscaped = false;
          break;
        } else {
          currentCommand += command;
          if (!commandStarted) {
            parsedCommands.push({
              command: MacroCommandType.RepeatEnd,
              argument: ""
            });
          }
          break;
        }
      default:
        if (commandStarted) {
          currentArgument += command;
        }
        break;
    }
  });
  return parsedCommands;
}
var MacroCommandType = /* @__PURE__ */ ((MacroCommandType2) => {
  MacroCommandType2[MacroCommandType2["PressKey"] = 0] = "PressKey";
  MacroCommandType2[MacroCommandType2["PressKeys"] = 1] = "PressKeys";
  MacroCommandType2[MacroCommandType2["AddText"] = 2] = "AddText";
  MacroCommandType2[MacroCommandType2["AddComment"] = 3] = "AddComment";
  MacroCommandType2[MacroCommandType2["RepeatStart"] = 4] = "RepeatStart";
  MacroCommandType2[MacroCommandType2["RepeatEnd"] = 5] = "RepeatEnd";
  MacroCommandType2[MacroCommandType2["Delay"] = 6] = "Delay";
  return MacroCommandType2;
})(MacroCommandType || {});

// src/main.ts
var DEFAULT_SETTINGS = {
  touchbarItems: []
};
var TouchBarMacros = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.updateTouchBar();
    this.addSettingTab(new TouchBarSettingTab(this.app, this));
  }
  updateTouchBar() {
    const { BrowserWindow, TouchBar } = require("electron").remote;
    const items = this.settings.touchbarItems.map((item) => {
      return new TouchBar.TouchBarButton({
        label: item["label"],
        backgroundColor: item["backgroundColor"],
        click: () => {
          executeMacro(this.app, item["macro"]);
        }
      });
    });
    const touchbar = new TouchBar({
      items
    });
    const win = BrowserWindow.getFocusedWindow();
    win.setTouchBar(touchbar);
  }
  onunload() {
    const { BrowserWindow } = require("electron").remote;
    const win = BrowserWindow.getFocusedWindow();
    win.setTouchBar(null);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var TouchBarSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Touch Bar Items" });
    containerEl.createEl("p", { text: "To add an item to your Touch Bar, click the button below. You can then edit the item in the list below." });
    const modifyOrAddArray = async (item) => {
      const index = this.plugin.settings.touchbarItems.findIndex((element) => element.id === item.id);
      if (index === -1) {
        this.plugin.settings.touchbarItems.push(item);
      } else {
        this.plugin.settings.touchbarItems[index] = item;
      }
      this.plugin.updateTouchBar();
      await this.plugin.saveSettings();
    };
    const renderTouchbarItem = (item) => {
      const itemEl = itemContainer.createDiv("touchbar-item");
      const moveButtons = itemEl.createDiv("move-buttons-div");
      const moveUp = moveButtons.createEl("button", "touchbar-item-button");
      (0, import_obsidian.setIcon)(moveUp, "chevron-up");
      const moveDown = moveButtons.createEl("button", "touchbar-item-button");
      (0, import_obsidian.setIcon)(moveDown, "chevron-down");
      moveUp.addEventListener("click", async () => {
        var _a;
        const index = this.plugin.settings.touchbarItems.findIndex((element) => element.id === item.id);
        if (index > 0) {
          this.plugin.settings.touchbarItems.splice(index - 1, 0, this.plugin.settings.touchbarItems.splice(index, 1)[0]);
          this.plugin.updateTouchBar();
          await this.plugin.saveSettings();
          (_a = itemEl.previousSibling) == null ? void 0 : _a.before(itemEl);
        }
      });
      moveDown.addEventListener("click", async () => {
        var _a;
        const index = this.plugin.settings.touchbarItems.findIndex((element) => element.id === item.id);
        if (index < this.plugin.settings.touchbarItems.length - 1) {
          this.plugin.settings.touchbarItems.splice(index + 1, 0, this.plugin.settings.touchbarItems.splice(index, 1)[0]);
          this.plugin.updateTouchBar();
          await this.plugin.saveSettings();
          (_a = itemEl.nextSibling) == null ? void 0 : _a.after(itemEl);
        }
      });
      const labelIn = itemEl.createEl("input", {
        type: "text",
        value: item["label"]
      });
      labelIn.classList.add("touchbar-item-input");
      labelIn.placeholder = "Label";
      const colorIn = itemEl.createEl("input", {
        type: "color",
        value: item["backgroundColor"]
      });
      colorIn.classList.add("touchbar-item-input");
      colorIn.placeholder = "Background Color";
      const makroIn = itemEl.createEl("input", {
        type: "text",
        value: item["macro"]
      });
      makroIn.classList.add("touchbar-item-input");
      makroIn.classList.add("wide-input");
      makroIn.placeholder = "Macro";
      const removeButton = itemEl.createEl("button", "touchbar-item-button remove-button");
      (0, import_obsidian.setIcon)(removeButton, "x");
      removeButton.onclick = async () => {
        this.plugin.settings.touchbarItems = this.plugin.settings.touchbarItems.filter((i) => i !== item);
        await this.plugin.saveSettings();
        this.plugin.updateTouchBar();
        itemEl.remove();
      };
      labelIn.onchange = async () => {
        item["label"] = labelIn.value;
        await modifyOrAddArray(item);
      };
      colorIn.onchange = async () => {
        item["backgroundColor"] = colorIn.value;
        await modifyOrAddArray(item);
      };
      makroIn.onchange = async () => {
        item["macro"] = makroIn.value;
        await modifyOrAddArray(item);
      };
    };
    new import_obsidian.Setting(containerEl).setName("Add Touch Bar item").setDesc('Click the "+" button to start creating a new Touch Bar item.').addButton((cb) => {
      cb.setButtonText("Add").onClick(async () => {
        renderTouchbarItem(new ObsidianTouchBarItem("", "#FFFFFF", ""));
      }).setTooltip("Add a new touchbar item").setIcon("plus").setCta();
    });
    const itemContainer = containerEl.createEl("div");
    itemContainer.createEl("h2", { text: "Current Touch Bar Items" });
    const touchbarItems = this.plugin.settings.touchbarItems;
    console.log(touchbarItems);
    for (let i = 0; i < touchbarItems.length; i++) {
      renderTouchbarItem(touchbarItems[i]);
    }
    containerEl.createEl("hr");
    containerEl.createEl("h2", { text: "Macros" });
    const description = containerEl.createEl("p", { text: "Use macros to give your Touch Bar items functionality, but be careful as these can have the ability to modify files in unintended ways! If you unsure please consider trying out the macro in a new vault first. " });
    description.classList.add("touchbar-settings-description");
    description.createEl("a", {
      text: "List of available keycodes",
      href: "https://www.electronjs.org/docs/latest/api/accelerator#available-key-codes"
    });
    const macroTable = containerEl.createEl("table", "touchbar-macro-table");
    const macroTableHead = macroTable.createEl("thead");
    const macroTableHeadRow = macroTableHead.createEl("tr");
    const macroTableHeadRowName = macroTableHeadRow.createEl("th");
    const macroTableHeadRowName2 = macroTableHeadRow.createEl("th");
    const macroTableHeadRowName3 = macroTableHeadRow.createEl("th");
    macroTableHeadRowName.setText("Syntax");
    macroTableHeadRowName2.setText("Description");
    macroTableHeadRowName3.setText("Example");
    const macroTableBody = macroTable.createEl("tbody");
    const { macros } = require_macro_desc();
    for (let i = 0; i < macros.length; i++) {
      const row = macroTableBody.createEl("tr");
      const name = row.createEl("td", "touchbar-macro-table-border");
      const desc = row.createEl("td", "touchbar-macro-table-border");
      const example = row.createEl("td", "touchbar-macro-table-border");
      name.setText(macros[i]["syntax"]);
      desc.setText(macros[i]["description"]);
      example.setText(macros[i]["example"]);
    }
  }
};
